name: Create Release on Version Update

on:
  push:
    branches:
      - main

# Configuration variables
env:
  FILTER_FILE: no-comment.txt
  VERSION_PREFIX: "! Version:"
  RELEASE_NAME_PREFIX: "No-comment"
  SECTION_TITLE_WHATS_CHANGED: "What's Changed"
  SECTION_TITLE_NEW_FILTERS: "New Filters"
  SECTION_TITLE_UPDATED: "Updated"
  SECTION_TITLE_REMOVED: "Removed"
  FOOTER_FULL_CHANGELOG_TEXT: "Full Changelog"

jobs:
  check-version-and-release:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: Extract current version
        id: current_version
        run: |
          VERSION=$(grep "^${{ env.VERSION_PREFIX }}" ${{ env.FILTER_FILE }} | sed 's/${{ env.VERSION_PREFIX }} //')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $VERSION"
      
      - name: Extract previous version
        id: previous_version
        run: |
          git checkout HEAD~1 -- ${{ env.FILTER_FILE }} 2>/dev/null || echo "No previous version"
          if [ -f ${{ env.FILTER_FILE }} ]; then
            PREV_VERSION=$(grep "^${{ env.VERSION_PREFIX }}" ${{ env.FILTER_FILE }} | sed 's/${{ env.VERSION_PREFIX }} //')
            echo "prev_version=$PREV_VERSION" >> $GITHUB_OUTPUT
            echo "Previous version: $PREV_VERSION"
          else
            echo "prev_version=0" >> $GITHUB_OUTPUT
          fi
          git checkout HEAD -- ${{ env.FILTER_FILE }}
      
      - name: Check if version changed
        id: version_check
        run: |
          PREV_VER="${{ steps.previous_version.outputs.prev_version }}"
          CURR_VER="${{ steps.current_version.outputs.version }}"
          
          # Skip if this is the first commit (no previous version)
          if [ -z "$PREV_VER" ]; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "First commit detected - skipping release creation"
            exit 0
          fi
          
          if [ "$CURR_VER" != "$PREV_VER" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "Version changed from $PREV_VER to $CURR_VER"
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "Version unchanged"
          fi
      
      - name: Generate release notes
        if: steps.version_check.outputs.changed == 'true'
        id: release_notes
        run: |
          set -e  # Exit on error
          
          # Get diff and filter out comment lines
          git diff HEAD~1 HEAD -- ${{ env.FILTER_FILE }} | grep -E "^[\+\-]" | grep -v "^[\+\-]!" | grep -v "^[\+\-][\+\-]" > changes.diff || true
          
          # Check if we have any changes
          if [ ! -s changes.diff ]; then
            echo "No filter changes detected, only metadata updated"
            touch added.txt removed.txt
          else
            # Extract added lines (new filters)
            grep "^+" changes.diff | sed 's/^+//' > added.txt || touch added.txt
            
            # Extract removed lines
            grep "^-" changes.diff | sed 's/^-//' > removed.txt || touch removed.txt
          fi
          
          # Create a Python script to analyze changes by domain
          cat > analyze.py << 'PYTHON'
          import re
          from collections import defaultdict
          
          def extract_domains(line):
              """Extract all domains from a line, handling comma-separated lists"""
              domains = []
              
              # Pattern 1: Comma-separated domains before ##
              # Example: domain1.com,domain2.com,domain3.com## selector
              comma_match = re.match(r'^([a-zA-Z0-9.,-]+)##', line)
              if comma_match:
                  domain_list = comma_match.group(1)
                  # Split by comma and extract each domain
                  for item in domain_list.split(','):
                      item = item.strip()
                      # Match domain pattern
                      domain_match = re.search(r'([a-zA-Z0-9.-]+\.(?:com|fr|net|org|eu|uk|co|tv|io|de|ca|au|jp|cn|ru|br|in|mx|es|it|nl|se|no|dk|fi|ch|at|be|cz|pl|gr|pt|ie|nz|za|kr|tw|hk|sg|my|th|vn|id|ph))', item)
                      if domain_match:
                          domains.append(domain_match.group(1))
              else:
                  # Pattern 2: Single domain with || prefix
                  # Example: ||domain.com^
                  single_match = re.search(r'(?:\|\||^)([a-zA-Z0-9.-]+\.(?:com|fr|net|org|eu|uk|co|tv|io|de|ca|au|jp|cn|ru|br|in|mx|es|it|nl|se|no|dk|fi|ch|at|be|cz|pl|gr|pt|ie|nz|za|kr|tw|hk|sg|my|th|vn|id|ph))', line)
                  if single_match:
                      domains.append(single_match.group(1))
              
              return domains
          
          def analyze_files():
              added = defaultdict(int)
              removed = defaultdict(int)
              
              # Read added filters
              try:
                  with open('added.txt', 'r') as f:
                      for line in f:
                          line = line.strip()
                          if line:
                              domains = extract_domains(line)
                              for domain in domains:
                                  added[domain] += 1
              except:
                  pass
              
              # Read removed filters
              try:
                  with open('removed.txt', 'r') as f:
                      for line in f:
                          line = line.strip()
                          if line:
                              domains = extract_domains(line)
                              for domain in domains:
                                  removed[domain] += 1
              except:
                  pass
              
              # Determine new, updated, and removed domains
              all_domains = set(added.keys()) | set(removed.keys())
              new_domains = []
              updated_domains = []
              removed_domains = []
              
              for domain in sorted(all_domains):
                  added_count = added.get(domain, 0)
                  removed_count = removed.get(domain, 0)
                  
                  if added_count > 0 and removed_count == 0:
                      new_domains.append((domain, added_count))
                  elif added_count > 0 and removed_count > 0:
                      net_change = added_count - removed_count
                      if net_change > 0:
                          updated_domains.append((domain, added_count))
                      elif net_change < 0:
                          removed_domains.append((domain, removed_count))
                      else:
                          updated_domains.append((domain, added_count))
                  elif removed_count > 0:
                      removed_domains.append((domain, removed_count))
              
              return new_domains, updated_domains, removed_domains
          
          new, updated, removed = analyze_files()
          
          print("NEW_DOMAINS_START")
          for domain, count in new:
              print(f"{domain}|{count}")
          print("NEW_DOMAINS_END")
          
          print("UPDATED_DOMAINS_START")
          for domain, count in updated:
              print(f"{domain}|{count}")
          print("UPDATED_DOMAINS_END")
          
          print("REMOVED_DOMAINS_START")
          for domain, count in removed:
              print(f"{domain}|{count}")
          print("REMOVED_DOMAINS_END")
          PYTHON
          
          # Run analysis
          python3 analyze.py > analysis.txt
          
          # Parse results and build release notes
          cat > build_notes.sh << 'BASH'
          #!/bin/bash
          
          # Configuration
          SECTION_WHATS_CHANGED="${{ env.SECTION_TITLE_WHATS_CHANGED }}"
          SECTION_NEW_FILTERS="${{ env.SECTION_TITLE_NEW_FILTERS }}"
          SECTION_UPDATED="${{ env.SECTION_TITLE_UPDATED }}"
          SECTION_REMOVED="${{ env.SECTION_TITLE_REMOVED }}"
          FOOTER_CHANGELOG="${{ env.FOOTER_FULL_CHANGELOG_TEXT }}"
          
          # Get commit SHA for diff link
          COMMIT_SHA=$(git rev-parse HEAD)
          PREV_SHA=$(git rev-parse HEAD~1)
          REPO_URL=$(git config --get remote.origin.url | sed 's/\.git$//' | sed 's/git@github.com:/https:\/\/github.com\//')
          
          echo "## ${SECTION_WHATS_CHANGED}" > release_notes.md
          echo "" >> release_notes.md
          
          # Parse new domains
          NEW_SECTION=$(sed -n '/NEW_DOMAINS_START/,/NEW_DOMAINS_END/p' analysis.txt | grep -v "DOMAINS")
          if [ -n "$NEW_SECTION" ]; then
              echo "### ${SECTION_NEW_FILTERS}" >> release_notes.md
              while IFS='|' read -r domain count; do
                  if [ -n "$domain" ]; then
                      echo "- **${domain}**" >> release_notes.md
                  fi
              done <<< "$NEW_SECTION"
              echo "" >> release_notes.md
          fi
          
          # Parse updated domains
          UPDATED_SECTION=$(sed -n '/UPDATED_DOMAINS_START/,/UPDATED_DOMAINS_END/p' analysis.txt | grep -v "DOMAINS")
          if [ -n "$UPDATED_SECTION" ]; then
              echo "### ${SECTION_UPDATED}" >> release_notes.md
              while IFS='|' read -r domain count; do
                  if [ -n "$domain" ]; then
                      echo "- **${domain}**" >> release_notes.md
                  fi
              done <<< "$UPDATED_SECTION"
              echo "" >> release_notes.md
          fi
          
          # Parse removed domains
          REMOVED_SECTION=$(sed -n '/REMOVED_DOMAINS_START/,/REMOVED_DOMAINS_END/p' analysis.txt | grep -v "DOMAINS")
          if [ -n "$REMOVED_SECTION" ]; then
              echo "### ${SECTION_REMOVED}" >> release_notes.md
              while IFS='|' read -r domain count; do
                  if [ -n "$domain" ]; then
                      echo "- **${domain}**" >> release_notes.md
                  fi
              done <<< "$REMOVED_SECTION"
              echo "" >> release_notes.md
          fi
          
          # Add full changelog link
          echo "---" >> release_notes.md
          echo "" >> release_notes.md
          echo "**${FOOTER_CHANGELOG}**: ${REPO_URL}/compare/${PREV_SHA}...${COMMIT_SHA}" >> release_notes.md
          BASH
          
          chmod +x build_notes.sh
          ./build_notes.sh
          
          echo "Release notes generated:"
          cat release_notes.md
      
      - name: Create Release
        if: steps.version_check.outputs.changed == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.current_version.outputs.version }}
          name: "${{ env.RELEASE_NAME_PREFIX }} v${{ steps.current_version.outputs.version }}"
          body_path: release_notes.md
          files: ${{ env.FILTER_FILE }}
          draft: true
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
